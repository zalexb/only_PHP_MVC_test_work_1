-- phpMyAdmin SQL Dump
-- version 4.7.3
-- https://www.phpmyadmin.net/
--
-- Хост: 127.0.0.1:3306
-- Время создания: Фев 08 2018 г., 16:21
-- Версия сервера: 5.6.37
-- Версия PHP: 7.0.21

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET AUTOCOMMIT = 0;
START TRANSACTION;
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- База данных: `test_vj`
--

-- --------------------------------------------------------

--
-- Структура таблицы `comments`
--

CREATE TABLE `comments` (
  `id` int(10) UNSIGNED NOT NULL,
  `name` tinytext NOT NULL,
  `content` mediumtext NOT NULL,
  `post_id` int(10) UNSIGNED NOT NULL,
  `created_at` datetime NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `comments`
--

INSERT INTO `comments` (`id`, `name`, `content`, `post_id`, `created_at`) VALUES
(8, 'Алексей', 'Неплохо', 15, '2018-02-08 15:07:43'),
(9, 'Алина', 'Здорово!', 21, '2018-02-08 15:17:22'),
(10, 'Коля', 'Мощно', 15, '2018-02-08 15:18:37'),
(11, 'Нина', 'Бред', 15, '2018-02-08 15:18:45'),
(12, 'Альберт', 'Моя статья лучше', 15, '2018-02-08 15:18:56'),
(13, 'Windows', 'Купите 10 версию', 15, '2018-02-08 15:19:12'),
(14, 'Linux', 'Моя ОС получше будет', 15, '2018-02-08 15:19:28');

-- --------------------------------------------------------

--
-- Структура таблицы `posts`
--

CREATE TABLE `posts` (
  `id` int(10) UNSIGNED NOT NULL,
  `name` tinytext NOT NULL,
  `content` mediumtext NOT NULL,
  `created_at` datetime NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `posts`
--

INSERT INTO `posts` (`id`, `name`, `content`, `created_at`) VALUES
(15, 'Валерий', 'Асинхронная работа с сокетами на C/C++ с libevent\r\n5 февраля 2018\r\n\r\nПомните, как когда-то мы писали простой TCP-сервер на C, а потом разбирали типичные ошибки? Описанный в этих статьях подход прекрасно работает, но только до тех пор, пока количество одновременно обслуживаемых соединений невелико — условно, пара сотен. Если же вам нужно обслуживать 10 или 50 тысяч соединений (так называемая проблема C10K), программу нужно писать совершенно иначе. Давайте разберемся, почему так, и как же нужно писать.\r\n\r\nСуть проблемы\r\nПочему же не работает просто держать 10 000 сокетов и обслуживать каждый из них в отдельном треде? Дело в том, что треды не бесплатны — операционная система выделяет под треды память, а также распределяет между ними время CPU. Переключение контекста конкретного ядра CPU с одного треда на другой — операция тоже не бесплатная. Это не проблема, когда тредов всего лишь несколько сотен. Но когда счет идет на тысячи тредов, больше времени начинает тратиться на переключение контекстов, чем на выполнение полезной работы.\r\n\r\nМожно ли уменьшить число тредов и при этом продолжить обслуживать 10 000 соединений? Оказывается, что можно. Простейшее решение заключается в использовании системного вызова select(), который позволяет по списку файловых дескрипторов определить, какие из них стали готовы для заданного класса операций ввода-вывода. Возможности select(), правда, не безграничны — хорошо работает он только в случае, если файловых дескрипторов не больше сотни. Поэтому для решения той же задачи в современных операционных системах есть лишенные этого недостатка системные вызовы: в Linux это epoll, во FreeBSD — kqueue, в Windows — IOCP.\r\n\r\nПоскольку на разных платформах системные вызовы разные, было разработано несколько библиотек, предоставляющих соответствующий слой абстракции. В качестве примеров можно привести библиотеки libevent, libev и libuv. Эти библиотеки имеют немного разные компромиссы. К примеру, libev не поддерживает Windows, потому что, действительно, кто же использует Windows на серверах, да еще и обслуживающих столько соединений?\r\n\r\nВ рамках этой заметки мы сосредоточим свое внимание на библиотеке libevent. Помимо прочего, libevent интересен тем, что имеет отличную документацию на Doxygen, кучу примеров, и даже небольшую бесплатную книжку. Библиотека используется в множестве известных проектов, таких, как Chromium, Memcached, Tor, Transmission и PgBouncer. Кроме того, у libevent есть ряд интересных фичей, например, встроенных асинхронный HTTP-сервер.', '2018-02-08 15:03:06'),
(16, 'Андрей', 'В прошлом посте, посвященном STM32, мы познакомились с платами Nucleo, программой STM32CubeMX, узнали, как программировать под STM32 в Linux, а также осилили базовые операции с GPIO. Сегодня же мы поговорим об использовании аппаратной реализации UART. В рамках данного поста мы будем использовать UART исключительно для обмена данными с компьютером. Однако с тем же успехом его можно применять и для взаимодействия с внешними модулями.\r\nСоздадим новый проект в STM32CubeMX. Как и в прошлый раз, я буду использовать отладочную плату NUCLEO-F411RE, однако для других плат отличия не будут большими.\r\nВо вкладке Pinout находим пины с пометками USART2_RX и USART2_TX — это пины PA2 и PA3. Они уже выбраны, как пины, которые будут использованы для UART, но соответствующая периферия на данный момент отключена. Включить ее можно, найдя в дереве слева USART2 и выбрав Asynchronous в выпадающем списке Mode:', '2018-02-08 15:09:17'),
(17, 'Александр', 'Ранее мы познакомились с IceStorm, открытым набором инструментов для разработки под FPGA серии Lattice iCE40, а также дешевой отладочной платой iCEstick на базе чипа ICE40HX1K. Кроме того, с использованием IceStorm, iCEstick и языка SystemVerilog нам удалось сделать электронные часы. Сегодня же при помощи тех же инструментов мы попробуем поработать со звуком. Однако на пути к этой благородной цели таится преграда, да не одна!\r\nПожалуй, главная проблема заключается в том, что для создания звука (во всяком случае, приятного) нужно генерировать честный аналоговый сигнал, не ШИМ. Чип ICE40HX1K такого не умеет, а значит понадобится ЦАП — устройство для перевода единичек и ноликов в аналоговый сигнал. Можно было бы просто найти в магазине подходящий ЦАП. Но я подумал, что намного интереснее будет спаять наш собственный из уже известных нам компонентов. Тем более, что это не так уж и трудно.', '2018-02-08 15:10:46'),
(18, 'Альберт', 'Год назад я писал о бейдже в форме матрешки, который можно было получить на конференции ZeroNights 2016. В этом, или точнее, уже прошлом, 2017 году, на ZeroNights у организаторов одного из железных стендов также можно было получить плату-бейдж. На сей раз плата называлась Кракен и имела форму осьминога (или ананаса, смотря какой стороной повернуть :D). Кракен представляет собой отладочную плату на базе STM32F405RGT6. Насколько я смог выяснить, плату разработали Арсений Жгилев и Антон Канышев.\r\nПервая проблема, возникшая у меня при пайке Кракена, заключалась в том, что обозначения компонентов в BOM и на шелкографии расходились. Ниже приведен скорректированный список необходимых компонентов с информацией о том, куда их нужно впаивать, и где можно купить:\r\nМикроконтроллер STM32F405RGT6 — 1 шт (DA1);\r\nКварцевый резонатор SMD 16 МГц — 1 шт (Z1);\r\nLDO регулятор напряжения LD3985M33R — 1 шт (DA2);\r\nИС управления питанием и зарядом Li-Ion BQ2057CSN — 1 шт (DA3);\r\nFDN306P P-channel MOSFET — 1 шт (VT1);\r\nДиод Шоттки B240A — 2 шт (VD1, VD2);\r\nСветодиод 0603 — 11 шт (H1 — H11);\r\nРезистор 220 Ом 0603 — 9 шт (R1-R8, R12);\r\nРезистор 10K 0603 — 4 шт (R9, R10, R18, R19);\r\nРезистор 620 Ом 0603 — 2 шт (R11, R16);\r\nРезистор 0.2 Ом 1206 — 1 шт (R13);\r\nРезистор 1 кОм 0603 — 3 шт (R14, R15, R17);\r\nКонденсатор 0.1 uF 0603 — 11 шт (C1-C6, C14, C15, C17, C20, C21);\r\nКонденсатор 4.7 uF 0805 — 2 шт (C7, C23);\r\nКонденсатор 0.01 uF 0603 — 2 шт (C8, C18);\r\nКонденсатор 22 pF 0603 — 2 шт (C9, C10);\r\nКонденсатор 1 uF 0603 — 3 шт (C11, C16, C19);\r\nКонденсатор 2.2 uF 0805 — 3 шт (C12, C13, C22);\r\nSMD-кнопка 7914J-1-000E или похожая — 1 шт (Q1);\r\nMiniUSB разъем USB/M-1J — 1 шт (X2);\r\nOLED-дисплей 0.96″ с SPI-интерфейсом на базе SSD1306 — 1 шт (DA4);\r\nОтмечу, что мелкие SMD резисторы и конденсаторы легко теряются, поэтому лучше взять их с небольшим запасом. OLED-дисплей в силу понятных причин является опциональным. Также понадобится некоторое количество гнезд и штырьков с шагом 2.54 мм, но я думаю, что они у вас и так есть. Наконец, к списку стоит добавить разъем IDC-10. Далее станет понятно, зачем.\r\nFun fact! Внимательные читатели к этому моменту уже догадались, что плата умеет работать от Li-Ion аккумулятора, а также заряжать этот аккумулятор от USB. А вы прошли проверку на внимательность?', '2018-02-08 15:15:33'),
(19, 'Николай', 'Типичные веб-проекты, разрабатываемые на чем-то вроде Python или PHP, характерны тем, что они создают большое количество соединений к СУБД — по одному, а иногда даже и по несколько, на каждый HTTP-запрос. Имея классическую архитектуру «один процесс на соединение», PostgreSQL не очень хорошо справляется с большим (условно, больше 100) количеством соединений. Решить проблему позволяет пулер соединений под названием PgBouncer. Благодаря использованию библиотеки libevent, PgBouncer может поддерживать большое количество (тысячи) соединений, которые проксируются на несколько (пара десятков) соединений непосредственно к PostgreSQL.\r\nДанная заметка предполагает, что на сервере у вас используется Ubuntu Linux, так как сегодня это, по всей видимости, наиболее популярный серверный дистрибутив Linux. Отличия описанный далее шагов для других дистрибутивов будут минимальными. Также предполагается, что на сервере уже установлен PostgreSQL. Установка и начальная настройка PostgreSQL ранее подробно рассматривались в статье Начало работы с PostgreSQL.', '2018-02-08 15:15:53'),
(20, 'Linux', 'Ранее мы выяснили, как разрабатывать под микроконтроллеры STM32 с использованием знакомой и понятной многим Arduino IDE. Этот подход, впрочем, не лишен недостатков. В частности, он (1) вводит лишние слои абстракции, что не позволяет писать максимально эффективный и компактный код, (2) работает с весьма ограниченным множеством микроконтроллеров и плат, а также (3) привязан к конкретной среде разработки, и не самой лучшей. Поэтому сегодня мы научимся разрабатывать под STM32 по-взрослому.\r\nВажно! Порог вхождения в мир STM32 довольно высокий. Если вы никогда раньше не работали с микроконтроллерами, я бы рекомендовал начинать с плат Arduino и микроконтроллеров AVR.\r\nНеобходимый софт\r\nНам понадобятся следующие пакеты, часть из которых уже упоминалась в предыдущем посте:\r\nyaourt -S arm-none-eabi-gcc arm-none-eabi-gdb \r\n  arm-none-eabi-newlib stlink stm32cubemx openocd\r\nЗдесь приведены названия пакетов для Arch Linux, но я довольно уверен, что в других дистрибутивах Linux они называются так же, или как-то похоже. Если вам не удастся найти готовый пакет с STM32CubeMX, программу можно скачать отсюда (потребуется регистрация). Для работы приложению требуется виртуальная машина Java. Несмотря на то, что программа имеет расширение .exe, она превосходно запускается в Linux через java -jar file.exe.\r\nОпционально вы также можете загрузить программу STLinkUpgrade, доступную для скачивания здесь (также потребуется регистрация). Эта программа предназначена для обновления прошивки программаторов STLink, что нередко приводит к исправлению багов, ну или как минимум к лучшим сообщениям об ошибках. Как и STM32CubeMX, эта программа написана на Java.', '2018-02-08 15:16:38'),
(21, 'Василий', 'В детстве я много времени проводил за игровой приставкой Sega Mega Drive, также известной, как Sega Genesis. Одна из интересных особенностей этой приставки заключается в том, что джойстики подключаются к ней через обычный DE9-порт. Теоретически, сигнал от джойстика должно быть достаточно просто декодировать. Джойстик от ретро-приставки видится мне интересным примитивом для использования в будущих DIY проектах, в связи с чем я решил попробовать сынтегрировать его с Arduino.\r\nДостаточно толковая информация о декодировании сигнала от джойстика была найдена по следующим ссылкам:\r\nSega Six Button Controller Hardware Info;\r\nUSB Adapter for Sega Genesis Controller;\r\nСам же джойстик, если у вас его нет, достаточно легко найти на eBay по запросу вроде «Sega Controller». Цена джойстика составляет в районе 2-3$. Вот как он выглядит:', '2018-02-08 15:16:58'),
(22, 'Лиза', 'Традиционно платы травят хлорным железом, как это ранее было описано в статье про лазерно-утюжную технологию. Однако хлорное железо имеет ряд недостатков. В частности, оно оставляет несмываемые пятна на одежде и мебели. Плюс к этому хлорное железо продается только в специализированных магазинах и стоит сравнительно дорого. Поэтому сегодня мы рассмотрим альтернативный и лишенный названных недостатков подход, заключающийся в использовании перекиси водорода, лимонной кислоты и поваренной соли.\r\nНичего из описанного далее я не придумывал сам, лишь отважно нашел через Google. Первоисточником, насколько я смог выяснить, является статья Безопасный общедоступный состав для травления меди в домашних условиях на сайте radiokot.ru, которую написал некто под ником Murlock в 2012 году. Впрочем, не исключаю, что такой способ травления плат мог быть независимо переоткрыт несколькими людьми. Статья классная и всячески рекомендуется к прочтению, здесь же я всего лишь привожу краткую выжимку.\r\nИтак, нам понадобятся:\r\n3%-ый раствор перекиси водорода. Баночка со 100 мл раствора была куплена в ближайшей аптеке за 12 рублей (0.21$);\r\nЛимонная кислота. Пакетик с 50 г лимонной кислоты обошелся мне в ближайшем продуктовом магазине в 35 рублей (0.60$);\r\nПоваренная соль. Есть в любой солонке и эффективно ничего не стоит;\r\nЭти компоненты смешиваются в стеклянной или пластиковой посуде в соотношении чайная ложка лимонной кислоты (это около 7.5 г) на 25 мл перекиси водорода, плюс чайная ложка соли. Количество соли не зависит от количества двух других реагентов, так как соль здесь выступает в качестве катализатора', '2018-02-08 15:18:05');

--
-- Индексы сохранённых таблиц
--

--
-- Индексы таблицы `comments`
--
ALTER TABLE `comments`
  ADD PRIMARY KEY (`id`),
  ADD KEY `post_id` (`post_id`);

--
-- Индексы таблицы `posts`
--
ALTER TABLE `posts`
  ADD PRIMARY KEY (`id`),
  ADD UNIQUE KEY `id` (`id`);

--
-- AUTO_INCREMENT для сохранённых таблиц
--

--
-- AUTO_INCREMENT для таблицы `comments`
--
ALTER TABLE `comments`
  MODIFY `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=15;
--
-- AUTO_INCREMENT для таблицы `posts`
--
ALTER TABLE `posts`
  MODIFY `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=23;
--
-- Ограничения внешнего ключа сохраненных таблиц
--

--
-- Ограничения внешнего ключа таблицы `comments`
--
ALTER TABLE `comments`
  ADD CONSTRAINT `comments_ibfk_1` FOREIGN KEY (`post_id`) REFERENCES `posts` (`id`);
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
